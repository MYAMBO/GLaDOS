# SLIECE

**SLIECE** is a minimalist, expression-oriented programming language designed for clarity, purity, and just a little bit of mischief.

Its name comes from the fusion of **slice** (precision, data slicing, computation) and **lie** (elegance, abstraction, and the subtle illusions of programming itself).

SLIECE encourages developers to think *functionally* — every operation returns a value, and functions are the foundation of all computation.  
Its syntax is compact and readable, making it an ideal environment for both experimentation and structured problem-solving.

Programs are written in files with the `.lie` extension, and **every program must define a `main` function**, the single entry point where execution begins.

---

## Philosophy and Design Goals

SLIECE is built upon three core principles:

### **Simplicity**
Code should be easy to read, write, and reason about.  
The syntax is minimal, behavior is predictable, and unnecessary keywords are banished.

### **Purity**
Functions are self-contained and deterministic.  
No side effects, no surprises — the same input always produces the same output.

### **Transparency through Abstraction**
Abstractions in SLIECE simplify code without sacrificing understanding.  
Every concept can be broken down into smaller, comprehensible *slices*.

Together, these principles make SLIECE both a **teaching language** and a **serious tool** for logical and mathematical exploration.

---

## Inspirations and Context

SLIECE draws from modern minimalist languages such as **Zig**, **Rust**, and **Python**,  
but its heart lies closer to **Lisp** and **ML**, emphasizing structure through simplicity.

The `.lie` file extension is a playful nod to *"The cake is a lie"*,  
a reminder that even elegant syntax hides the machinery beneath.

But make no mistake — SLIECE rewards **discipline with precision**.  
By enforcing pure expressions and a clear `main` entry point, it turns constraint into clarity.

---

## Documentation

Further details about SLIECE’s syntax, parsing rules, and internal mechanisms can be found in:

- **`Doc/`** – General documentation and conceptual guides
- **`documentation/`** – Detailed language specifications
- **`Parsing/`** – Parser design and grammar implementation

---

### “Clarity through constraint. Truth through the lie.”

---

Designed by Yanis Monté, Martin Bonte, Enzo Dubeaurepaire, Timoté Koenig and Antoine Orange

